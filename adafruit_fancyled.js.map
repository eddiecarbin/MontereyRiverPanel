{"version": 3, "mappings": "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", "sources": ["adafruit_fancyled.py"], "names": ["__version__", "__repo__", "red", "CHSV", "hsv", "hue", "hsv.hue", "sxt", "floor", "frac", "r", "g", "b", "invsat", "hsv.saturation", "this.red", "hsv.value", "this.green", "this.blue", "clamp", "normalize", "green", "blue", "key", "IndexError", "denormalize", "h", "this.hue", "s", "this.saturation", "v", "this.value", "CRGB", "new CRGB(this).pack", "max", "lower", "min", "val", "upper", "inplace", "i", "n", "weight2", "weight1", "color1", "color2", "color1.hue", "color2.hue", "sat", "color1.saturation", "color2.saturation", "color1.value", "color2.value", "unpack", "color1.red", "color2.red", "color1.green", "color2.green", "color1.blue", "color2.blue", "GFACTOR", "gamma_value", "Math.pow", "brightness", "list", "tuple", "newlist", "newlist.append", "x", "gamma_red", "gamma_green", "gamma_blue", "brightness_red", "brightness_green", "brightness_blue", "x.red", "x.green", "x.blue", "val.red", "val.green", "val.blue", "position", "palette", "palette.length", "idx", "mix", "gradient", "sorted", "least", "most", "length", "pos", "below", "above", "gradient.length"], "sourcesContent": ["# The MIT License (MIT)\n#\n# Copyright (c) 2017 PaintYourDragon for Adafruit Industries\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in\n# all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n# THE SOFTWARE.\n\"\"\"\n`adafruit_fancyled.adafruit_fancyled`\n====================================================\n\nFancyLED is a CircuitPython library to assist in creating buttery smooth LED animation.\nIt's loosely inspired by the FastLED library for Arduino, and in fact we have a \"helper\"\nlibrary using similar function names to assist with porting of existing Arduino FastLED\nprojects to CircuitPython.\n\n* Author(s): PaintYourDragon\n\"\"\"\n\n# imports\n\n__version__ = \"0.0.0-auto.0\"\n__repo__ = \"https://github.com/Adafruit/Adafruit_CircuitPython_FancyLED.git\"\n\nfrom math import floor\n\n\n# FancyLED provides color- and palette-related utilities for LED projects,\n# offering a buttery smooth look instead of the usual 8-bit-like \"blip blip\"\n# effects often seen with LEDs.  It's loosely inspired by, but NOT a drop-in\n# replacement for, the FastLED library for Arduino.\n\n\nclass CRGB:\n    \"\"\"Color stored in Red, Green, Blue color space.\n\n       One of two ways: separate red, gren, blue values (either as integers\n       (0 to 255 range) or floats (0.0 to 1.0 range), either type is\n       'clamped' to valid range and stored internally in the normalized\n       (float) format), OR can accept a CHSV color as input, which will be\n       converted and stored in RGB format.\n\n       Following statements are equivalent - all return red:\n\n       .. code-block:: python\n\n             c = CRGB(255, 0, 0)\n             c = CRGB(1.0, 0.0, 0.0)\n             c = CRGB(CHSV(0.0, 1.0, 1.0))\n    \"\"\"\n\n    def __init__(self, red, green=0.0, blue=0.0):\n        # pylint: disable=too-many-branches\n        if isinstance(red, CHSV):\n            # If first/only argument is a CHSV type, perform HSV to RGB\n            # conversion.\n            hsv = red  # 'red' is CHSV, this is just more readable\n            hue = hsv.hue * 6.0  # Hue circle = 0.0 to 6.0\n            sxt = floor(hue)  # Sextant index is next-lower integer of hue\n            frac = hue - sxt  # Fraction-within-sextant is 0.0 to <1.0\n            sxt = int(sxt) % 6  # mod6 the sextant so it's always 0 to 5\n\n            if sxt == 0:  # Red to <yellow\n                r, g, b = 1.0, frac, 0.0\n            elif sxt == 1:  # Yellow to <green\n                r, g, b = 1.0 - frac, 1.0, 0.0\n            elif sxt == 2:  # Green to <cyan\n                r, g, b = 0.0, 1.0, frac\n            elif sxt == 3:  # Cyan to <blue\n                r, g, b = 0.0, 1.0 - frac, 1.0\n            elif sxt == 4:  # Blue to <magenta\n                r, g, b = frac, 0.0, 1.0\n            else:  # Magenta to <red\n                r, g, b = 1.0, 0.0, 1.0 - frac\n\n            invsat = 1.0 - hsv.saturation  # Inverse-of-saturation\n\n            self.red = ((r * hsv.saturation) + invsat) * hsv.value\n            self.green = ((g * hsv.saturation) + invsat) * hsv.value\n            self.blue = ((b * hsv.saturation) + invsat) * hsv.value\n        else:\n            # Red, green, blue arguments (normalized floats OR integers)\n            # TODO(tannewt): Factor this out into a helper function\n            if isinstance(red, float):\n                self.red = clamp(red, 0.0, 1.0)\n            else:\n                self.red = normalize(red)\n            if isinstance(green, float):\n                self.green = clamp(green, 0.0, 1.0)\n            else:\n                self.green = normalize(green)\n            if isinstance(blue, float):\n                self.blue = clamp(blue, 0.0, 1.0)\n            else:\n                self.blue = normalize(blue)\n\n    def __repr__(self):\n        return (self.red, self.green, self.blue)\n\n    def __str__(self):\n        return \"(%s, %s, %s)\" % (self.red, self.green, self.blue)\n\n    def __len__(self):\n        \"\"\"Retrieve total number of color-parts available.\"\"\"\n        return 3\n\n    def __getitem__(self, key):\n        \"\"\"Retrieve red, green or blue value as iterable.\"\"\"\n        if key == 0:\n            return self.red\n        if key == 1:\n            return self.green\n        if key == 2:\n            return self.blue\n        raise IndexError\n\n    def pack(self):\n        \"\"\"'Pack' a `CRGB` color into a 24-bit RGB integer.\n\n           :returns: 24-bit integer a la ``0x00RRGGBB``.\n        \"\"\"\n\n        return (\n            (denormalize(self.red) << 16)\n            | (denormalize(self.green) << 8)\n            | (denormalize(self.blue))\n        )\n\n\nclass CHSV:\n    \"\"\"Color stored in Hue, Saturation, Value color space.\n\n       Accepts hue as float (any range) or integer (0-256 -> 0.0-1.0) with\n       no clamping performed (hue can 'wrap around'), saturation and value\n       as float (0.0 to 1.0) or integer (0 to 255), both are clamped and\n       stored internally in the normalized (float) format.  Latter two are\n       optional, can pass juse hue and saturation/value will default to 1.0.\n\n       Unlike `CRGB` (which can take a `CHSV` as input), there's currently\n       no equivalent RGB-to-HSV conversion, mostly because it's a bit like\n       trying to reverse a hash...there may be multiple HSV solutions for a\n       given RGB input.\n\n       This might be OK as long as conversion precedence is documented,\n       but otherwise (and maybe still) could cause confusion as certain\n       HSV->RGB->HSV translations won't have the same input and output.\n        \"\"\"\n\n    def __init__(self, h, s=1.0, v=1.0):\n        if isinstance(h, float):\n            self.hue = h  # Don't clamp! Hue can wrap around forever.\n        else:\n            self.hue = float(h) / 256.0\n        if isinstance(s, float):\n            self.saturation = clamp(s, 0.0, 1.0)\n        else:\n            self.saturation = normalize(s)\n        if isinstance(v, float):\n            self.value = clamp(v, 0.0, 1.0)\n        else:\n            self.value = normalize(v)\n\n    def __repr__(self):\n        return (self.hue, self.saturation, self.value)\n\n    def __str__(self):\n        return \"(%s, %s, %s)\" % (self.hue, self.saturation, self.value)\n\n    def __len__(self):\n        \"\"\"Retrieve total number of 'color-parts' available.\"\"\"\n        return 3\n\n    def __getitem__(self, key):\n        \"\"\"Retrieve hue, saturation or value as iterable.\"\"\"\n        if key == 0:\n            return self.hue\n        if key == 1:\n            return self.saturation\n        if key == 2:\n            return self.value\n        raise IndexError\n\n    def pack(self):\n        \"\"\"'Pack' a `CHSV` color into a 24-bit RGB integer.\n\n           :returns: 24-bit integer a la ``0x00RRGGBB``.\n        \"\"\"\n\n        # Convert CHSV to CRGB, return packed result\n        return CRGB(self).pack()\n\n\ndef clamp(val, lower, upper):\n    \"\"\"Constrain value within a numeric range (inclusive).\n    \"\"\"\n    return max(lower, min(val, upper))\n\n\ndef normalize(val, inplace=False):\n    \"\"\"Convert 8-bit (0 to 255) value to normalized (0.0 to 1.0) value.\n\n       Accepts integer, 0 to 255 range (input is clamped) or a list or tuple\n       of integers.  In list case, 'inplace' can be used to control whether\n       the original list is modified (True) or a new list is generated and\n       returned (False).\n\n       Returns float, 0.0 to 1.0 range, or list of floats (or None if inplace).\n    \"\"\"\n\n    if isinstance(val, int):\n        # Divide by 255 (not 256) so maximum level is 1.0.\n        return clamp(val, 0, 255) / 255.0\n\n    # If not int, is assumed list or tuple.\n    if inplace:\n        i = 0\n        # Modify list in-place (OK for lists, NOT tuples, no check made)\n        for n in val:\n            val[i] = normalize(n)\n            i += 1\n        return None\n\n    # Generate new list\n    return [normalize(n) for n in val]\n\n\ndef denormalize(val, inplace=False):\n    \"\"\"Convert normalized (0.0 to 1.0) value to 8-bit (0 to 255) value\n\n       Accepts float, 0.0 to 1.0 range or a list or tuple of floats.  In\n       list case, 'inplace' can be used to control whether the original list\n       is modified (True) or a new list is generated and returned (False).\n\n       Returns integer, 0 to 255 range, or list of integers (or None if\n       inplace).\n    \"\"\"\n\n    # 'Denormalizing' math varies slightly from normalize().  This is on\n    # purpose.  Multiply by 256 (NOT 255) and clip.  This ensures that all\n    # fractional values fall into the correct 'buckets' -- e.g. 0.999\n    # should return 255, not 254 -- and that the buckets are all equal-\n    # sized (usu. method of adding 0.5 before int() would miss this).\n    if isinstance(val, float):\n        return clamp(int(val * 256.0), 0, 255)\n\n    # If not int, is assumed list or tuple.\n    if inplace:\n        # Modify the list in-place (OK for lists, NOT tuples, no check made)\n     \n        i = 0\n        # Modify list in-place (OK for lists, NOT tuples, no check made)\n        for n in val:\n            val[i] = denormalize(n)\n            i += 1\n        return None\n\n    # Generate new list\n    return [denormalize(n) for n in val]\n\n\ndef unpack(val):\n    \"\"\"'Unpack' a 24-bit color into a `CRGB` instance.\n\n       :param int val:  24-bit integer a la ``0x00RRGGBB``.\n       :returns: CRGB color.\n       :rtype: CRGB\n    \"\"\"\n\n    # See notes in normalize() for math explanation.  Large constants here\n    # avoid the usual shift-right step, e.g. 16711680.0 is 255 * 256 * 256,\n    # so we can just mask out the red and divide by this for 0.0 to 1.0.\n    return CRGB(\n        (val & 0xFF0000) / 16711680.0,  # Red\n        (val & 0x00FF00) / 65280.0,  # Green\n        (val & 0x0000FF) / 255.0,\n    )  # Blue\n\n\ndef mix(color1, color2, weight2=0.5):\n    \"\"\"Blend between two colors using given ratio. Accepts two colors (each\n       may be `CRGB`, `CHSV` or packed integer), and weighting (0.0 to 1.0)\n       of second color.\n\n       :returns: `CRGB` color in most cases, `CHSV` if both inputs are `CHSV`.\n    \"\"\"\n\n    clamp(weight2, 0.0, 1.0)\n    weight1 = 1.0 - weight2\n\n    if isinstance(color1, CHSV):\n        if isinstance(color2, CHSV):\n            # Both colors are CHSV -- interpolate in HSV color space\n            # because of the way hue can cross the unit boundary...\n            # e.g. if the hues are 0.25 and 0.75, the center point is\n            # 0.5 (cyan)...but if you want hues to wrap the other way\n            # (with red at the center), you can have hues of 1.25 and 0.75.\n            hue = color1.hue + ((color2.hue - color1.hue) * weight2)\n            sat = color1.saturation * weight1 + color2.saturation * weight2\n            val = color1.value * weight1 + color2.value * weight2\n            return CHSV(hue, sat, val)\n        # Else color1 is HSV, color2 is RGB.  Convert color1 to RGB\n        # before doing interpolation in RGB space.\n        color1 = CRGB(color1)\n        # If color2 is a packed integer, convert to CRGB instance.\n        if isinstance(color2, int):\n            color2 = unpack(color2)\n    else:\n        if isinstance(color2, CHSV):\n            # color1 is RGB, color2 is HSV.  Convert color2 to RGB\n            # before interpolating in RGB space.\n            color2 = CRGB(color2)\n        elif isinstance(color2, int):\n            # If color2 is a packed integer, convert to CRGB instance.\n            color2 = unpack(color2)\n        # If color1 is a packed integer, convert to CRGB instance.\n        if isinstance(color1, int):\n            color1 = unpack(color1)\n\n    # Interpolate and return as CRGB type\n    return CRGB(\n        (color1.red * weight1 + color2.red * weight2),\n        (color1.green * weight1 + color2.green * weight2),\n        (color1.blue * weight1 + color2.blue * weight2),\n    )\n\n\nGFACTOR = 2.7  # Default gamma-correction factor for function below\n\n\ndef gamma_adjust(val, gamma_value=None, brightness=1.0, inplace=False):\n    \"\"\"Provides gamma adjustment for single values, `CRGB` and `CHSV` types\n       and lists of any of these.\n\n       Works in one of three ways:\n         1. Accepts a single normalized level (0.0 to 1.0) and optional\n            gamma-adjustment factor (float usu. > 1.0, default if\n            unspecified is GFACTOR) and brightness (float 0.0 to 1.0,\n            default is 1.0). Returns a single normalized gamma-corrected\n            brightness level (0.0 to 1.0).\n         2. Accepts a single `CRGB` or `CHSV` type, optional single gamma\n            factor OR a (R,G,B) gamma tuple (3 values usu. > 1.0), optional\n            single brightness factor OR a (R,G,B) brightness tuple.  The\n            input tuples are RGB even when a `CHSV` color is passed. Returns\n            a normalized gamma-corrected `CRGB` type (NOT `CHSV`!).\n         3. Accept a list or tuple of normalized levels, `CRGB` or `CHSV`\n            types (and optional gamma and brightness levels or tuples\n            applied to all). Returns a list of gamma-corrected values or\n            `CRGB` types (NOT `CHSV`!).\n\n       In cases 2 and 3, if the input is a list (NOT a tuple!), the 'inplace'\n       flag determines whether a new tuple/list is calculated and returned,\n       or the existing value is modified in-place.  By default this is\n       'False'.  If you try to inplace-modify a tuple, an exception is raised.\n\n       In cases 2 and 3, there is NO return value if 'inplace' is True --\n       the original values are modified.\n    \"\"\"\n    # pylint: disable=too-many-branches\n\n    if isinstance(val, float):\n        # Input value appears to be a single float\n        if gamma_value is None:\n            gamma_value = GFACTOR\n        return Math.pow(val, gamma_value) * brightness\n\n    if isinstance(val, (list, tuple)):\n        # List or tuple of values\n        if isinstance(val[0], float):\n            # Input appears to be a list of floats\n            if gamma_value is None:\n                gamma_value = GFACTOR\n            if inplace:\n                i = 0\n                for x in val:\n                    val[i] = Math.pow(val[i], gamma_value) * brightness\n                    i += 1\n                return None\n            newlist = []\n            for x in val:\n                newlist.append(Math.pow(x, gamma_value) * brightness)\n            return newlist\n        # List of CRGB or CHSV...we'll get back to that in a moment...\n        # but first determine gamma-correction factors for R,G,B:\n        if gamma_value is None:\n            # No gamma specified, use default\n            gamma_red, gamma_green, gamma_blue = GFACTOR, GFACTOR, GFACTOR\n        elif isinstance(gamma_value, float):\n            # Single gamma value provided, apply to R,G,B\n            gamma_red, gamma_green, gamma_blue = (gamma_value, gamma_value, gamma_value)\n        else:\n            gamma_red, gamma_green, gamma_blue = (\n                gamma_value[0],\n                gamma_value[1],\n                gamma_value[2],\n            )\n        if isinstance(brightness, float):\n            # Single brightness value provided, apply to R,G,B\n            brightness_red, brightness_green, brightness_blue = (\n                brightness,\n                brightness,\n                brightness,\n            )\n        else:\n            brightness_red, brightness_green, brightness_blue = (\n                brightness[0],\n                brightness[1],\n                brightness[2],\n            )\n        if inplace:\n            i = 0\n            for x in val:\n                if isinstance(x, CHSV):\n                    x = CRGB(x)\n                val[i] = CRGB(\n                    Math.pow(x.red, gamma_red) * brightness_red,\n                    Math.pow(x.green, gamma_green) * brightness_green,\n                    Math.pow(x.blue, gamma_blue) * brightness_blue,\n                )\n                i += 1\n            return None\n        newlist = []\n        for x in val:\n            if isinstance(x, CHSV):\n                x = CRGB(x)\n            newlist.append(\n                CRGB(\n                    Math.pow(x.red, gamma_red) * brightness_red,\n                    Math.pow(x.green, gamma_green) * brightness_green,\n                    Math.pow(x.blue, gamma_blue) * brightness_blue,\n                )\n            )\n        return newlist\n\n    # Single CRGB or CHSV value\n    if gamma_value is None:\n        # No gamma specified, use default\n        gamma_red, gamma_green, gamma_blue = GFACTOR, GFACTOR, GFACTOR\n    elif isinstance(gamma_value, float):\n        # Single gamma value provided, apply to R,G,B\n        gamma_red, gamma_green, gamma_blue = (gamma_value, gamma_value, gamma_value)\n    else:\n        gamma_red, gamma_green, gamma_blue = (\n            gamma_value[0],\n            gamma_value[1],\n            gamma_value[2],\n        )\n    if isinstance(brightness, float):\n        # Single brightness value provided, apply to R,G,B\n        brightness_red, brightness_green, brightness_blue = (\n            brightness,\n            brightness,\n            brightness,\n        )\n    else:\n        brightness_red, brightness_green, brightness_blue = (\n            brightness[0],\n            brightness[1],\n            brightness[2],\n        )\n\n    if isinstance(val, CHSV):\n        val = CRGB(val)\n\n    return CRGB(\n        Math.pow(val.red, gamma_red) * brightness_red,\n        Math.pow(val.green, gamma_green) * brightness_green,\n        Math.pow(val.blue, gamma_blue) * brightness_blue,\n    )\n\n\ndef palette_lookup(palette, position):\n    \"\"\"Fetch color from color palette, with interpolation.\n\n    :param palette: color palette (list of CRGB, CHSV and/or packed integers)\n    :param float position: palette position (0.0 to 1.0, wraps around).\n\n    :returns: `CRGB` or `CHSV` instance, no gamma correction applied.\n    \"\"\"\n\n    position %= 1.0  # Wrap palette position in 0.0 to <1.0 range\n\n    weight2 = position * len(palette)  # Scale position to palette length\n    idx = int(floor(weight2))  # Index of 'lower' color (0 to len-1)\n    weight2 -= idx  # Weighting of 'upper' color\n\n    color1 = palette[idx]  # Fetch 'lower' color\n    idx = (idx + 1) % len(palette)  # Get index of 'upper' color\n    color2 = palette[idx]  # Fetch 'upper' color\n\n    return mix(color1, color2, weight2)\n\n\ndef expand_gradient(gradient, length):\n    \"\"\"Convert gradient palette into standard equal-interval palette.\n\n    :param sequence gradient: List or tuple of of 2-element lists/tuples\n      containing position (0.0 to 1.0) and color (packed int, CRGB or CHSV).\n      It's OK if the list/tuple elements are either lists OR tuples, but\n      don't mix and match lists and tuples -- use all one or the other.\n\n    :returns: CRGB list, can be used with palette_lookup() function.\n    \"\"\"\n\n    gradient = sorted(gradient)  # Sort list by position values\n    least = gradient[0][0]  # Lowest position value (ostensibly 0.0)\n    most = gradient[-1][0]  # Highest position value (ostensibly 1.0)\n    newlist = []\n\n    for i in range(length):\n        pos = i / float(length - 1)  # 0.0 to 1.0 in 'length' steps\n        # Determine indices in list of item 'below' and 'above' pos\n        if pos <= least:\n            # Off bottom of list - use lowest index\n            below, above = 0, 0\n        elif pos >= most:\n            # Off top of list - use highest index\n            below, above = -1, -1\n        else:\n            # Seek position between two items in list\n            below, above = 0, -1\n            n = 0\n            for x in gradient:\n                if pos >= x[0]:\n                    below = n\n                n += 1\n            n = len(gradient)\n            # for x in gradient[-1:0:-1]:\n            #     if pos <= x[0]:\n            #         above = -1 - n\n            #     n -= 1\n            while n >= 0:\n                x = gradient[n-1]\n                if pos <= x[0]:\n                    above = -1 - n\n                n -= 1\n\n        # Range between below, above\n        r = gradient[above][0] - gradient[below][0]\n        if r <= 0:\n            newlist.append(gradient[below][1])  # Use 'below' color only\n        else:\n            weight2 = (pos - gradient[below][0]) / r  # Weight of 'above' color\n            color1 = gradient[below][1]\n            color2 = gradient[above][1]\n            # Interpolate and add to list\n            newlist.append(mix(color1, color2, weight2))\n\n    return newlist\n"]}